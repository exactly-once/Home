## Introduction
[Delivery guarantees](TODO: link-to-previous-post) of modern messaging infrastructures make it non-trivial to build roboust distributed systems. This post goes through problems that system builders have to tackle and see how idempotency can help. Not some generic idempotency though but quite a special flavour. 

## Unboxing idempotency

There are a couple of definitions of idempotency but the one we will use here states that: 

> An operation `f` is idempotent if `f(f(x)) = f(x)`. 

Put differently, this means that no matter how many times the operation is applied on input `x` the outcome is the same as if the operation was performed just once. 

In order to get some intuition let's figure out what `f` and `x` stand for in practice. To cover different flavours of practical architectures let's assume that our system consists of a number of endpoints. Each endpoint owns a distinct piece of state and the only way for the endpoints to communicate is by sending messages. Every endpoint processes input messages one by one, modifying it's internal state and producing new messages (1).

*Diagram*: endpoint with state that processes a message multiple times

In this context `f` stands for business logic executed when a message gets processed. `x` on the other hand, represents all resources modified during business logic execution as well as all messages produced. 

## Shoot the target

It's worth going through a trivial example to see what does idempotency mean in a more concrete settings. Let's imagine that our system models a moving target shooting range. It consists of a single `ShootingRange` endpoint which stores shooting target's location `{int: TargetPosition }` and processes `FireAt : { int: Position }` messages. Whenever `FireAt` message gets processed the endpoint produces either `Hit` or `Missed` event to indicate the result.

The logic executed for `FireAt` messages is:

``` C#
void Handle(FireAt message)
{
    if(this.TargetPosition == message.Position) 
    {
        Publish(new Hit());
    }
    else 
    {
        Publish(new Missed());
    }
}
```

For any concrete `FireAt`, say `FireAt : { Position = 42 }` and moving target at position `2`, the execution of business logic can be written as:

> f_[Position=42]: {TargetPosition=2} -> ({TargetPosition=2}, {`Missed`})

Looking at the message handling logic it's easy to see that for any value of `Position` in the `FireAt` message the execution logic satisfies the idempotency property i.e. no matter how many times the message gets processed the result is the same as if it was process exactly once. 

## Leader board (idempotency but with Ids)

Let's extend our system with a second `LeaderBoard` endpoint that's responsible for storing number of unique target hits for the player. The endpoint processes `Hit` messages generated by the `ShootingRange`:

``` C# 
void Handle(Hit message)
{
    this.NumberOfHits++;
}
```

This implementation is idempotent but doesn't meet business requirements. With the current message payload there is no way for `LeaderBoard` to distinguish two logically different `FireAt` messages from two duplicates generated by the infrastructure. When `LeaderBoard` receives `Hit` message it has no way to tell if there's been a hit made by the palyer or if it's just duplicate of some other `Hit` message already processed.

The only way to cope with duplicates is by making sure we can test message equality at the business level. This can be achieved by modeling messages as immutable facts or intents with **unique identity** rather than values (3).

This can be done if we assume that `FireAt` message gets extends with e.g. `AttemptId` property that than gets passed to the `Hit` event. With that in place `LeaderBoard` logic becomes:

``` C#
void Handle(Hit message)
{
    if(this.Hits.Contains(message.AttemptId))
    {
        return;
    }

    this.Hits.Add(message.AttemptId);
    this.NumberOfHits++;
}
```

What this trivial scenario shows is that generic idempotency is not enough to deal with message duplicates. We need business level identifiers to deal with duplicated messages.

## Stats endpoint (idempotency with re-ordering is not enough!) (game controller )

Now let's add one more moving piece to our system - `GameScenario` endpoint that changes current location of the moving target using `MoveTarget` message. Now the `ShootingRange` logic becomes:

``` C#
void Handle(FireAt message)
{
    if(this.ShootingTarget == message.Target) 
    {
        Publish(new Hit { AttemptId = message.AttemptId });
    }
    else
    {
        Publish(new Missed { AttemptId = message.AttemptId });
    } 
}

void Handle(MoveTarget message)
{
    this.ShootingTarget = message.Location;
}
```

Let's analyze one possible scenarion in which both `FireAt` and `MoveTarget` messages get processed. At the beginning the `ShootingTarget` equals `42`, the palyers sends `FireAt : {Target: 42}` and `GameScenario` sends `MoveTarget : {Location: 1}`. Due to possible delivery characteristics (duplication and re-ordering) what happens is that `FireAt` gets processed first, than `MoveTarget` and finally a duplicate of `FireAt`. 

This results in two messages being published by the `ShootingRange` i.e. `Hit` and `Miss` both for the same logical `FireAt` message. Our operations are idempotent, yet we ended up with two messages representing two contradictory facts about the same attempt. We did not end-up with an unexpected state. Worse than that, we ended up in a state which indicates that two logically exclusive alternatives occured. 

Why didn't idempotency help us? The reason is that the same operation was performed on different state. Idempotency describes what happens for duplicated, successive message processing which is not the case here. In the context of our definition, `x` for both invocations was different. First it was the old value of `ShootingTarget` i.e. `42` and later the new one i.e `1`. 

One, theoretical option, to fix this would be to keep historical versions of the state and map them to business level message identifier. So if a duplciate arrives it operates on the exactly same state as the first copy of the message processed. Alternativelly, we could keep track of all messages processed and make processing operation no-op for any duplicates that arrive:

``` C#
void Handle(FireAt message)
{
    if(this.Processed.Contains(message.AttemptId))
    {
        return;
    }
    else
    {
        this.Processed.Add(message.AttemptId);

        if(this.ShootingTarget == message.Target) 
        {
            Publish(new Hit { AttemptId = message.AttemptId });
        }
        else
        {
            Publish(new Missed { AttemptId = message.AttemptId });
        }
    } 
}
```

In fact we should probably do the same for `MoveTarget` handler.

## Target moves (fragile idempotency)

Idempotency is quite fragile and easy to break - even in our trivial system. Let's imagine that we decided to change the target's position with each `FireAt` event. We could start off setting the new position to be the same as `Target` value in the message. Is this still idempotent? Sure. The content of input message is immutable to the new position will always be the same. 

What if we tweaked the logic this way:

``` C#
void Handle(FireAt message)
{
    if(this.ShootingTarget == message.Target) 
    {
        this.ShootingTarget = new Rand().Next(MaxLocation);

        Publish(new Hit());
    }
    else
    {
        Publish(new Missed());
    } 
}
```

Now whenever the target gets hit we choose the new position randomly. Not and overly fancy change, yet enough to break idempotency. The indeterminism introduced by `new Rand().Next(MaxLocation)` makes each re-processing of the same message likely to result in different `ShootingTarget` position.

What this shows is an instance of a broader scenario. Whenever the logic depends on values outside of our control that can change between executions, the operation is no longer idempotent. This includes not only random numbers, but things like GUIDs, local clock values, results of queries to the local file system or remote APIs. If you depend on time or GUID identifiers you need to make then deterministic (1). 

## Summary

As we could see in this post idempotency is hard to manage at the business level and easy to break by accident. What is even more important is that in practical applications generic idempotency is too weak to protect us from anomalies caused by the communication infrastructure. 

What we need is business level identity for our messages and a mechanism to deterministically process duplicates, ideally without a need to store each and every version of the state managed by an endpoint.

## To be contined

Now that we know a bit more about message processing in distributed systems we will look as possible ways of dealing with the problems and more specifically if and when it's possible to solve it at the infrastructure level. 

(1) - this covers quite a wide range of systems. Including REST best microservice architectures.
(2) - Azure Durable Functions
(3) - similarlity to Value Objects and Entities in DDD
