## Introduction
[Delivery guarantees](TODO: link-to-previous-post) of modern messaging infrastructures make it non-trivial to build roboust distributed systems. This post goes through problems that system builders have to tackle and shows how idempotency can help. Not some generic idempotency though but quite a special flavour. 

## Unboxing idempotency

There are a couple of definitions of idempotency but the one we will use here states that: 

> An operation `f` is idempotent if `f(f(x)) = f(x)`. 

Put differently, this means that no matter how many times the operation is applied on input `x` the outcome is the same as if the operation was performed just once. 

In order to get some intuition let's figure out what `f` and `x` stand for in practice. Let's assume that our system consists of endpoints, each owning a distinct piece of state. The only way for the endpoints to communicate is by sending messages. Every endpoint processes input messages one by one, modifying it's internal state and producing new messages (1).

*Diagram*: endpoint with state that processes a message multiple times

In this context `f` stands for business logic executed when a message gets processed. `x` on the other hand, represents all resources modified during business logic execution as well as all messages produced. 

## Shoot the target

Let's imagine that our system models a moving target shooting range. It consists of a single `ShootingRange` endpoint which stores shooting target's location `{int: TargetPosition }` and processes `FireAt : { int: Position }` messages. Whenever `FireAt` message gets processed the endpoint produces either `Hit` or `Missed` event to indicate the result.

The logic executed for `FireAt` messages is:

``` C#
void Handle(FireAt message)
{
    if(this.TargetPosition == message.Position) 
    {
        Publish(new Hit());
    }
    else 
    {
        Publish(new Missed());
    }
}
```

For any concrete `FireAt`, say `FireAt : { Position = 42 }` and moving target at position `2`, the execution of business logic can be written as:

> f_[FireAt:Position=42]({TargetPosition=2}) = ({TargetPosition=2}, {`Missed`})

Looking at the message handling logic it's easy to see that for any value of `Position` in the `FireAt` message the execution logic satisfies the idempotency property i.e. no matter how many times the message gets processed the result is the same as if it was process exactly once. 

## Leader board (idempotency but with Ids)

Let's extend our system with a second `LeaderBoard` endpoint that's responsible for storing number of unique target hits for the player. The endpoint processes `Hit` messages generated by the `ShootingRange`:

``` C# 
void Handle(Hit message)
{
    this.NumberOfHits++;
}
```

This implementation is idempotent but doesn't meet business requirements. With the current message payload there is no way for `LeaderBoard` to distinguish two logically different `FireAt` messages from two duplicates generated by the infrastructure. When `LeaderBoard` receives `Hit` message it has no way to tell if there's been a new hit made by the palyer or if it's just duplicate of some other `Hit` message already processed.

The only way to cope with duplicates is by making sure we can test message equality at the business level. This can be achieved by modeling messages as immutable facts or intents with **unique identity** rather than values (3).

If we extend `FireAt` message with `AttemptId` property (unique for each attempt the player makes) it can be used as a identifier for the `Hit` event. With that in place `LeaderBoard` logic becomes:

``` C#
void Handle(Hit message)
{
    if(this.Hits.Contains(message.AttemptId))
    {
        return;
    }
    this.Hits.Add(message.AttemptId);
    
    this.NumberOfHits++;
}
```

Tis trivial scenario shows that generic idempotency is not enough to deal with message duplicates. Business level identifiers are a must.

## Stats endpoint (re-ordering requires exactly-once processing)

Let's add another moving piece to our system - `GameScenario` endpoint that changes current position of the moving target using `MoveTarget` message. New mesage gets handled by `ShootingRange`:

``` C#
void Handle(FireAt message)
{
    if(this.TargetPosition == message.Position) 
    {
        Publish(new Hit { AttemptId = message.AttemptId });
    }
    else
    {
        Publish(new Missed { AttemptId = message.AttemptId });
    } 
}

void Handle(MoveTarget message)
{
    this.TargetPosition = message.Position;
}
```

Let's analyze a possible message processing scenarion incuding `FireAt` and `MoveTarget` messages. At the beginning the `TargetPosition` equals `42`, the player sends `FireAt : { Postion: 42 }` and `GameScenario` sends `MoveTarget : {Position: 1}`. Due to delivery characteristics (duplication and re-ordering) what happens is that `FireAt` gets processed first, than `MoveTarget` and finally a duplicate of `FireAt`. 

*Diagram*: show how the messages get processed and results

This results in two messages being published by the `ShootingRange` - `Hit` and `Missed` both for the same logical `FireAt` message. Our operations are idempotent, our messages have well defined business identity, yet **we ended up with two messages representing two contradictory facts about the same attempt**. 

We didn't end-up with an unexpected state e.g. with an attempt resulting with miss when we expected a hit. It's far worse than that! We ended up in a state which indicates that two logically exclusive alternatives occured. A state which is invalid by any standard.

### Exactly-once processing

Why didn't idempotency help us? It's because `FireAt` duplciate was processed using a different version of `ShootingRage` state than the first time. Idempotency describes what happens for duplicated, **successive** message processing. It has nothing to do with the same operation being peformed on a different inputs which is the case here. The value of `x` from the deffintion was different in the first and the second execution. First it was the initial value of `TargetPosition` i.e. `42` and later the new one i.e `1`. 

In order to prevent "alternative-worlds" scenarion (the attempt both missed and hit the target) we need to ensure that once a logical message gets process no duplicate results in inconsistent observable side-effects. In our example that would translate to situation in which processing of `FireAt` duplicate results in publishing exact copy of the `Hit` event or no message at all.

Conceptually, this means that for any exectuion which includes duplicates, exteranlly the results of processing looks as if any duplicated message was processed **exactly-once**.

### Implementing exactly-once

One, theoretical option, to implement exactly-once would be to keep historical versions of the state mapped to business level message identifier. Having that we could re-process any duplciate using exactly same state as for the first successful processing. 

This comes with obvious prize in storage requried - we would need to each and every version. Secondly, we would need to make sure we capture the whole state used to produce side-effects. This includes any business data as well as GUID identifers used in produced messages, value of time used to execute logic, random numbers generated, file-system state query results, remote service responses - just to name some. This would depend on concreate logic executed and be different for each operation.

TODO: second approach

### Implementing exactly-once

One, theoretical option, to fix this would be to keep historical versions of the state and map them to business level message identifier. So if a duplciate arrives it operates on the exactly same state as the first copy of the message processed. Alternativelly, we could keep track of all messages processed and make processing operation no-op for any duplicates that arrive:

``` C#
void Handle(FireAt message)
{
    if(this.Processed.Contains(message.AttemptId))
    {
        return;
    }
    else
    {
        this.Processed.Add(message.AttemptId);

        if(this.ShootingTarget == message.Target) 
        {
            Publish(new Hit { AttemptId = message.AttemptId });
        }
        else
        {
            Publish(new Missed { AttemptId = message.AttemptId });
        }
    } 
}
```

In fact we should probably do the same for `MoveTarget` handler.

## Summary

TODO: we didn't talk about failures, and storage requirements. We will tackle that next.

As we could see in this post idempotency is hard to manage at the business level and easy to break by accident. What is even more important is that in practical applications generic idempotency is too weak to protect us from anomalies caused by the communication infrastructure. 

What we need is business level identity for our messages and a mechanism to deterministically process duplicates, ideally without a need to store each and every version of the state managed by an endpoint.

## To be contined

Now that we know a bit more about message processing in distributed systems we will look as possible ways of dealing with the problems and more specifically if and when it's possible to solve it at the infrastructure level. 

(1) - this covers quite a wide range of systems. Including REST best microservice architectures.
(2) - Azure Durable Functions
(3) - similarlity to Value Objects and Entities in DDD
