TL;DR; Achieving idempotency with business logic code is non-trivial and fragile. And even if done correctly, is not enough to build roboust distributed systems.

## Introduction

Idempotency can be a useful property when building distributed systems. It's easier said than done, however, to write idempotent code and keep it so under changing requirements. Finally, generic idempotency is not enough to deal with basic characteristics of communication in distributed systems.

## Unboxing idempotency

There are a couple of definitions of idempotency but the one we will use here states that: 

> An operation `f` is idempotent if `f(f(x)) = f(x)`. 

Put differently, this means that no matter how many times the operation is applied on input `x` the outcome is the same as if the operation was performed only once. 

In order to get some intuition let's figure out what `f` and `x` stand for in practice. To cover different flavours of practical architectures let's assume that our system consists of a number of endpoints. Each endpoint owns a distinct piece of state and the only way for the endpoints to communicate is by sending messages. Every endpoint processes input messages one by one, modifying it's internal state and producing new messages (1).

*Diagram*: endpoint with state that processes a message multiple times

In this context `f` stands for business logic executed when a message gets processed. `x` on the other hand, represents all resources modified during business logic execution as well as all messages produced. 

## Shoot the target

It's worth going through a trivial example to see what does idempotency means in a more concrete settings. Let's imagine that our system models a moving target shooting range. It consists of a single `ShootingRange` endpoint which stores shooting target's location `{int: ShootingTarget}` and processes `FireAt : { int: Target }` messages. Whenever `FireAt` message gets processed the endpoint produces either `Hit` or `Missed` event to indicate the result.

The logic executed when `FireAt` gets process is:

``` C#
void Handle(FireAt message)
{
    if(this.ShootingTarget == message.Target) 
    {
        Publish(new Hit());
    }
    else 
    {
        Publish(new Missed());
    }
}
```

For any concrete `FireAt` message, say `FireAt : { Target = 42 }` and moving target at location `2`, the execution of business logic can be written as:

> f_[Target=42]: {ShootingTarget=2}-> ({ShootingTarget=2}, {`Missed`})

Looking at the message handling logic it's easy to see that for any value of `Target` in the `FireAt` message the execution logic satisfies the idempotency property i.e. no matter how many times the message gets processed the result is the same as if it was process exactly once. 

## Target moves (fragile idempotency)

Idempotency is quite fragile and easy to break - even in our trivial system. Let's imagine that we decided to change the target's position with each `FireAt` event. We could start off setting the new position to be the same as `Target` value in the message. Is this still idempotent? Sure. The content of input message is immutable to the new position will always be the same. 

What if we tweaked the logic this way:

``` C#
void Handle(FireAt message)
{
    if(this.ShootingTarget == message.Target) 
    {
        this.ShootingTarget = new Rand().Next(MaxLocation);

        Publish(new Hit());
    }
    else
    {
        Publish(new Missed());
    } 
}
```

Now whenever the target gets hit we choose the new position randomly. Not and overly fancy change, yet enough to break idempotency. The indeterminism introduced by `new Rand().Next(MaxLocation)` makes each re-processing of the same message likely to result in different `ShootingTarget` position.

What this shows is an instance of a broader scenario. Whenever the logic depends on values outside of our control that can change between exectusion the operation is no longer idempotent. This includes not only random numbers, but things like Guids, local clock values, results of queries to the local file system or remote APIs. If you depend on time or guid identifiers you need to make then deterministics (1). 

## Leader board (idempotency but with ids)

Let's extend our system with a second endpoint i.e. `LeaderBoard` that's responsible for storing the number of unique target hits for the player. New endpoint will subscribe and process `Hit` events generated by the `ShootingRange`:

``` C# 
void Handle(Hit message)
{
    this.NumberOfHits++;
}
```

This operation is idempotent but is far from enough in light of possible message duplication. Duplicated `FireAt` messages will result in duplicated `Hit` messages that are indistinguishable from the `LeaderBoard` perspective. We end-up with all operations being idempotent yet with a serious flaw in our system.

What we need is ability to recognize duplicates at the business level and to be able to that we need some business level identify for each one of them. In other words we need logical message identifiers to be able to cope with duplicates at the logic level. 

This can be done if we assume that `FireAt` message gets extends with e.g. `AttemptId` property that than gets passed to the `Hit` event. With that in place `LeaderBoard` logic becomes:

``` C#
void Handle(Hit message)
{
    if(this.Hits.Contains(message.AttemptId))
    {
        return;
    }

    this.Hits.Add(message.AttemptId);
    this.NumberOfHits++;
}
```

What this trivial scenario shows is that generic idempotency is not enough to deal with message duplicates. We need business level identifiers to deal with duplicated messages.

## Stats endpoint (idempotency with re-ordering is not enough!) (game controller )

Now let's add one more moving piece to our system - `GameScenario` endpoint that changes current location of the moving target using `MoveTarget` message. Now the `ShootingRange` logic becomes:

``` C#
void Handle(FireAt message)
{
    if(this.ShootingTarget == message.Target) 
    {
        Publish(new Hit { AttemptId = message.AttemptId });
    }
    else
    {
        Publish(new Missed { AttemptId = message.AttemptId });
    } 
}

void Handle(MoveTarget message)
{
    this.ShootingTarget = message.Location;
}
```

Let's analyze one possible scenarion in which both `FireAt` and `MoveTarget` messages get processed. At the beginning the `ShootingTarget` equals `42`, the palyers sends `FireAt : {Target: 42}` and `GameScenario` sends `MoveTarget : {Location: 1}`. Due to possible delivery characteristics (duplication and re-ordering) what happens is that `FireAt` gets processed first, than `MoveTarget` and finally a duplicate of `FireAt`. 

This results in two messages being published by the `ShootingRange` i.e. `Hit` and `Miss` both for the same logical `FireAt` message. Our operations are idempotent, yet we ended up with two messages representing two contradictory facts about the same attempt. We did not end-up with an unexpected state. Worse than that, we ended up in a state which indicates that two logically exclusive alternatives occured. 

Why didn't idempotency help us? The reason is that the same operation was performed on different state. Idempotency describes what happens for duplicated, successive message processing which is not the case here. In the context of our definition, `x` for both invocations was different. First it was the old value of `ShootingTarget` i.e. `42` and later the new one i.e `1`. 

One, theoretical option, to fix this would be to keep historical versions of the state and map them to business level message identifier. So if a duplciate arrives it operates on the exactly same state as the first copy of the message processed. Alternativelly, we could keep track of all messages processed and make processing operation no-op for any duplicates that arrive:

``` C#
void Handle(FireAt message)
{
    if(this.Processed.Contains(message.AttemptId))
    {
        return;
    }
    else
    {
        this.Processed.Add(message.AttemptId);

        if(this.ShootingTarget == message.Target) 
        {
            Publish(new Hit { AttemptId = message.AttemptId });
        }
        else
        {
            Publish(new Missed { AttemptId = message.AttemptId });
        }
    } 
}
```

In fact we should probably do the same for `MoveTarget` handler.

## Summary

As we could see in this post idempotency is hard to manage at the business level and easy to break by accident. What is even more important is that in practical applications generic idempotency is too weak to protect us from anomalies caused by the communication infrastructure. 

What we need is business level identity for our messages and a mechanism to deterministically process duplicates, ideally without a need to store each and every version of the state managed by an endpoint.

## To be contined

Now that we know a bit more about message processing in distributed systems we will look as possible ways of dealing with the problems and more specifically if and when it's possible to solve it at the infrastructure level. 

(1) - this covers quite a wide range of systems. Including REST best microservice architectures.
(2) - Azure Durable Functions
