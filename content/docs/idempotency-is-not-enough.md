--- 
Title: Idempotency is not enough
Assumptions: The previous post introduces how duplicates and message re-ordering can happen
---

## Introduction
(Delivery guarantees)[TODO: link-to-the-previous-post] of modern messaging infrastructures make it non-trivial to build robust distributed systems. This post goes through problems that system builders have to tackle and shows how idempotency can help. Not some generic idempotency though but quite a special flavor. 

## Unboxing idempotency

There are a couple of definitions of idempotency but the one we will use here states that: 

> An operation `f` is idempotent if `f(f(x)) = f(x)`. 

Put differently, this means that no matter how many times the operation is applied on input `x` the outcome is the same as if the operation was performed just once. 

To get some intuition let us figure out what `f` and `x` stand for in practice. Let's assume that our system consists of endpoints, each owning a distinct piece of state. Every endpoint processes input messages one by one, modifying its internal state and producing new messages. Finally, the only way for the endpoints to communicate is by sending messages (1).

*Diagram*: endpoint with the state that processes a message multiple times

In this context `f` stands for business logic executed when a message gets processed and `x` represents the value of the state used during business logic execution as well as messages produced so far. The result of message execution i.e. `f(x)` captures the modified version of the state and any messages being produced. 

## Hit the target

Let's imagine that our system models a moving target shooting range. It consists of a single `ShootingRange` endpoint which stores shooting target's location `{int: TargetPosition }` and processes `FireAt : { int: Position }` messages. Whenever `FireAt` message gets processed the endpoint produces either `Hit` or `Missed` event to indicate the result.

The logic executed for `FireAt` messages is:

``` C#
void Handle(FireAt message)
{
    if(this.TargetPosition == message.Position) 
    {
        Publish(new Hit());
    }
    else 
    {
        Publish(new Missed());
    }
}
```

For any concrete `FireAt`, say `FireAt : { Position = 42 }` and moving target at position `2`, message processing can be written as:

> f_[FireAt:Position=42]({TargetPosition=2}, {}) = ({TargetPosition=2}, {`Missed`})

Looking at the message handling logic it's easy to see that for any value of `Position` in the `FireAt` message the execution logic satisfies the idempotency property i.e. no matter how many times the message gets processed the result is the same as if it was processed exactly once. 

## Leader board (idempotency but with Ids)

Let's extend our system with a second `LeaderBoard` endpoint that's responsible for storing the number of target hits for the player. The endpoint processes `Hit` messages generated by the `ShootingRange`:

``` C# 
void Handle(Hit message)
{
    this.NumberOfHits++;
}
```

This implementation is idempotent but far from meeting business requirements when deployed in any real-world environment. With the current message payload, there is no way for `LeaderBoard` to distinguish two logically different `FireAt` messages from two duplicates generated during delivery. When `LeaderBoard` receives `Hit` message it has no way to tell if there's been a new hit or if it's just duplicate of some other `Hit` message already processed.

The only way to cope with duplicates is by making sure we can test message equality at the business level. This can be achieved by modeling messages as immutable facts or intents with **unique identity** rather than values (3).

If we extend `FireAt` message with `AttemptId` property (unique for each attempt the player makes) it can be used as a identifier for the `Hit` event. With that in place `LeaderBoard` logic becomes:

``` C#
void Handle(Hit message)
{
    if(this.Hits.Contains(message.AttemptId))
    {
        return;
    }
    this.Hits.Add(message.AttemptId);
    
    this.NumberOfHits++;
}
```

Idempotency is not enough to deal with message duplicates. Business level identifiers are a must.

## Stats endpoint (re-ordering requires exactly-once processing)

Let's add another moving piece to our system - `GameScenario` endpoint that changes current position of the moving target using `MoveTarget` message. New message is handled by `ShootingRange`:

``` C#
void Handle(FireAt message)
{
    if(this.TargetPosition == message.Position) 
    {
        Publish(new Hit { AttemptId = message.AttemptId });
    }
    else
    {
        Publish(new Missed { AttemptId = message.AttemptId });
    } 
}

void Handle(MoveTarget message)
{
    this.TargetPosition = message.Position;
}
```

Let's analyze one possible message delivery scenarion incuding `FireAt` and `MoveTarget` messages. Let's assume we start with `TargetPosition` equal to `42`, the player sends `FireAt : { Postion: 42 }` and `GameScenario` sends `MoveTarget : {Position: 1}`. Due to duplication and re-ordering `FireAt` gets processed first, than `MoveTarget` and finally `FireAt` duplicate. 

*Diagram*: show how the messages get processed and results

This results in two messages being published by the `ShootingRange` - `Hit` and `Missed` both for the same `FireAt` message. Our logic is idempotent, our messages have a well-defined business identity, yet **we ended up with two messages representing two contradictory facts about the same attempt**. 

We didn't end up with an unexpected state e.g. with an attempt resulting with miss when we expected a hit. It's far worse than that! We ended up in a state which indicates that two logically exclusive alternatives occurred. A state which is simply corrupted.

### Exactly-once processing

Why didn't idempotency help us? It's because `FireAt` duplicate was processed using a different version of `ShootingRage` state than the first time. Idempotency describes what happens for duplicated, **successive** message processing. It says nothing about performing the same operation on different inputs - which is the case here. The value of `x` changed between the first and the second execution. Initially, `TargetPosition` was `42` and later changed to `1`. 

If we want to prevent "alternative-worlds" scenario (where the attempt both missed and hit the target), we need to ensure that once a logical message gets processed all duplicates result in consistent observable side-effects i.e. messages produced. In our example we need to guarantee that processing `FireAt` duplicate results in an exact copy of the first `Hit` event or that no message is published.

More generally, we want an endpoint to produce observable side-effects identical to some execution in which each logical message gets processed **exactly-once**. 

### Implementing exactly-once

One approach to implementing the required behavior would be to keep all historical versions of the state indexed by logical messages. With that in place, we could re-process any duplicate using the same state which would naturally produce the same side-effects. Of course, this requires additional storage. 

What is more troublesome is the fact that we need to store all pieces of the state needed. In practice, this includes not only strictly business data but things like system clock value, file-system query results, remote service responses as well as pseudo-random data put in the outgoing messages like GUIDs and timestamp - just to name a few. Finally, the state needed depends on concrete business logic and would have to be identified separately for every operation.

An alternative approach is based on capturing the side-effects and not the state used to produce them. What gets captured are not the historical versions of the state but rather the messages that got produced when processing a message. For the `FireAt` message this could like this:

``` C#
void Handle(FireAt message)
{
    if(this.SideEffects.Contains(message.AttemptId) == false)
    {
        var sideEffects;
    
        if(this.ShootingTarget == message.Target) 
        {
            sideEffect = new Hit { AttemptId = message.AttemptId };
        }
        else
        {
            sideEffect = new Missed { AttemptId = message.AttemptId };
        }
    
        SideEffects.Add(message.AttemptId, sideEffect);
    }
    
    Publish(SideEffects[message.AttemptId]);
}
```

This looks quite a bit more involved than the previous version. The thing to notice here, however, is the fact that the side-effects management logic is quite generic and independent of the business logic! 

This raises interesting questions: Can this be done generically, independent of the business logic? Does it require any guarantees from the storage used by the endpoint? How much data do we need for the side effects? Those are all interesting topics that we will be covered in the follow-up posts.

## Summary

Idempotency is often claimed to be a remedy for troubles caused by at-least-once delivery guarantees. In this post, we showed that's not necessarily the case unless we talk about it's stronger version - one that is business identity-aware and produces exactly-once side-effects in face of message reordering. 

It turns out that what we need is none trivial to implement but might be solvable in a generic manner at the level of infrastructure instead of business logic.

(1) - this covers quite a wide range of systems. Including REST best microservice architectures.
(2) - Azure Durable Functions
(3) - similarly to Value Objects and Entities in DDD
(4) - both scenarios are indistinguishable from the perspective of any receiving endpoint
